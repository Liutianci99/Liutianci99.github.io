{"posts":[{"title":"反转字符串","content":"题目 Leetcode 541： 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 题解 for循环+库函数 class Solution { public: string reverseStr(string s, int k) { for (int i = 0; i &lt; s.size(); i += 2 * k) { if (s.size() - (i + 1) &lt; k) { reverse(s.begin() + i, s.end()); } else { reverse(s.begin() + i, s.begin() + i + k); } } return s; } }; for循环+自定义翻转函数 class Solution { public: void my_reverse(string&amp; s, int start, int end) { while (start &lt; end) { int tmp = s[start]; s[start] = s[end]; s[end] = tmp; start ++; end --; } } string reverseStr(string s, int k) { for (int i = 0; i &lt; s.size(); i += 2 * k) { if (s.size() - (i + 1) &lt; k) { my_reverse(s, i, s.size() - 1); } else { my_reverse(s, i, i + k - 1); } } return s; } }; ","link":"https://liutianci99.github.io/post/fan-zhuan-zi-fu-chuan/"},{"title":"设计链表","content":"题目 Leetcode 707： 你可以选择使用单链表或者双链表，设计并实现自己的链表。 单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。 实现 MyLinkedList 类： MyLinkedList() 初始化 MyLinkedList 对象。 int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。 void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。 void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。 void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。 void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。 题解 单链表 class MyLinkedList { struct Linkedlist { int val; Linkedlist* next; Linkedlist(int val) : val(val), next(nullptr) {} }; public: MyLinkedList() { dummy_head = new Linkedlist(0); length = 0; } int get(int index) { if (index &lt; 0 || index &gt;= length) { return -1; } Linkedlist* curr = dummy_head-&gt;next; while (index--) { curr = curr-&gt;next; } return curr-&gt;val; } void addAtHead(int val) { Linkedlist* new_node = new Linkedlist(val); Linkedlist* curr = dummy_head-&gt;next; dummy_head-&gt;next = new_node; new_node-&gt;next = curr; length++; } void addAtTail(int val) { Linkedlist* curr = dummy_head; while (curr-&gt;next != nullptr) { curr = curr-&gt;next; } Linkedlist* new_node = new Linkedlist(val); curr-&gt;next = new_node; length++; } void addAtIndex(int index, int val) { if (index &lt; 0 || index &gt; length) { return; } if (index == length) { addAtTail(val); return; } Linkedlist* curr = dummy_head; while (index--) { curr = curr-&gt;next; } Linkedlist* tmp = curr-&gt;next; Linkedlist* new_node = new Linkedlist(val); curr-&gt;next = new_node; new_node-&gt;next = tmp; length++; } void deleteAtIndex(int index) { if (index &lt; 0 || index &gt;= length) { return; } Linkedlist* curr = dummy_head; while (index--) { curr = curr-&gt;next; } Linkedlist* node_to_delete = curr-&gt;next; curr-&gt;next = curr-&gt;next-&gt;next; delete node_to_delete; // Properly delete the node to avoid memory leaks length--; } private: int length; Linkedlist* dummy_head; }; ","link":"https://liutianci99.github.io/post/she-ji-lian-biao/"},{"title":"有序数组的平方","content":"题目 Leetcode 974： 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 题解 库函数（平方+排序） #include &lt;iostream&gt; #include &lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; vec = {-4,-1,0,3,10}; vector&lt;int&gt; result; for(int i:vec) { result.push_back(i * i); } sort(result.begin(), result.end()); for(int i:result) { cout &lt;&lt; i &lt;&lt; &quot; &quot;; } } 创建新的向量，先把原数组平方后的数填入，再排序。 双指针 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; vec = {-4,-1,0,3,10}; int length = vec.size() - 1; vector&lt;int&gt; result(length+1); for(int i=0, j = vec.size()-1; i &lt;= j;) { if(vec[i]*vec[i] &lt;= vec[j]*vec[j]) { result[length] = vec[j] * vec[j]; length --; j --; } else { result[length] = vec[i]*vec[i]; length --; i ++; } } for(int i=0; i &lt; result.size(); i++) { cout &lt;&lt; result[i] &lt;&lt; &quot; &quot;; } } 类似归并排序。由于原数组是有序的，所以可以按倒序，每次在原数组的两端选取最大值填入新数组。 ","link":"https://liutianci99.github.io/post/you-xu-shu-zu-de-ping-fang/"},{"title":"长度最小的子数组","content":"题目 Leetcode 209: 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其总和大于等于 target 的长度最小的 子数组[numsl, numsl+1, ..., numsr-1, numsr]，并返回其长度**。**如果不存在符合条件的子数组，返回0` 。 题解 暴力（双层for循环） #include &lt;iostream&gt; #include &lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; nums = {1,4,4}; int target = 4; int left = 0; int result = nums.size() + 1; int length = 0; for(int right = 0; left &lt; nums.size(); left ++) { int sum = 0; for(right = left; right &lt; nums.size(); right ++) { sum += nums[right]; if(sum &gt;= target) { length = right - left + 1; result = result &gt; length ? length : result; break; } } } if(result == nums.size() + 1) { return 0; } else { return result; } } 通过设置子数组的左、右边界来从小到大遍历所有子数组，如果有满足条件的数组则输出数组长度。但是在leetcode会超时。 滑动窗口 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; nums = {1,4,4}; int target = 4; int sum = 0; int left = 0; int length; int result = nums.size() + 1; for(int right = 0;right &lt; nums.size(); right ++) { sum += nums[right]; while(sum &gt;= target) { length = right - left + 1; result = result &lt; length ? result : length; sum -= nums[left]; left ++; } } result = (result == (nums.size()+1)) ? 0 : result; return result; } 先固定左边界，再通过移动右边界得到一个满足条件的子数组，在这个子数组内通过移动左边界得到最小长度的子数组。 ","link":"https://liutianci99.github.io/post/chang-du-zui-xiao-de-zi-shu-zu/"},{"title":"螺旋数组","content":"题目 Leetcode 59： Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order 题解 循环模拟（注意边界值） #include &lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n)); int loop = n / 2; int i, j; int start_i = 0, start_j = 0; int offset = 1; int number = 1; while(loop --) { i = start_i; j = start_j; // 循环是左闭右开的区间 for(;j &lt; n -offset; j++) { matrix[i][j] = number; number ++; } for(;i &lt; n - offset; i ++) { matrix[i][j] = number; number ++; } for(;j &gt; start_j; j--) { matrix[i][j] = number; number ++; } for(;i &gt; start_i; i--) { matrix[i][j] = number; number ++; } offset ++; start_j ++; start_i ++; } if(n % 2 == 1) { matrix[n/2][n/2] = n * n; } for(i = 0; i &lt; n; i++) { for(j = 0; j &lt; n; j++) { cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; &quot;\\n&quot;; } } 先生成矩阵然后往矩阵里填入数。根据不同的n确定需要螺旋几圈。把每一圈分为左闭右开的四次循环，注意每圈的边界值都不一样。 ","link":"https://liutianci99.github.io/post/luo-xuan-shu-zu/"},{"title":"四数之和","content":"题目 Leetcode 18： 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 题解 双指针 class Solution { public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; result; for (int i = 0; i &lt; nums.size(); i ++) { if (nums[i] &gt; 0 &amp;&amp; nums[i] &gt; target) break; if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i]) continue; for (int j = i + 1; j &lt; nums.size(); j ++) { if (nums[j] + nums[i] &gt; 0 &amp;&amp; nums[j] + nums[i] &gt; target) break; if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; int left = j + 1; int right = nums.size() - 1; while (left &lt; right) { if ((long)nums[i] + nums[j] + nums[left] + nums[right] &gt; target) { right --; } else if ((long)nums[i] + nums[j] + nums[left] + nums[right] &lt; target) { left ++; } else { result.push_back(vector&lt;int&gt;{nums[i], nums[j], nums[left], nums[right]}); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left ++; while (left &lt; right &amp;&amp; nums[right] == nums[right -1]) right --; left ++; right --; } } } } return result; } }; 和三数之和差不多，关键在于剪枝、去重。以及四数相加可能造成溢出，加上long变成长整型。 ","link":"https://liutianci99.github.io/post/si-shu-zhi-he/"},{"title":"三数之和","content":" 题目 Leetcode ： 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 **注意：**答案中不可以包含重复的三元组。 题解 哈希表（去重麻烦） 双指针 class Solution { public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; result; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums.size() - 2; i ++) { if (nums[i] &gt; 0) return result; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } int left = i + 1; int right = nums.size() - 1; while (left &lt; right) { if (nums[i] + nums[left] + nums[right] &gt; 0) { right --; } else if (nums[i] + nums[left] + nums[right] &lt; 0) { left ++; } else { result.push_back(vector&lt;int&gt;{nums[i], nums[left], nums[right]}); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left ++; while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right --; left ++; right --; } } } return result; } }; 重点在于先排序再去重。遍历数组，通过遍历的数i确定left，right。确定i，left，right的同时对三者进行去重。 ","link":"https://liutianci99.github.io/post/san-shu-zhi-he/"},{"title":"相交链表","content":"题目 Leetcode 面试题02.07： 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 题解 暴力循环 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if (headA == nullptr || headB == nullptr) { return NULL; } ListNode* currA; ListNode* currB; currA = headA; currB = headB; while (currA != nullptr) { if (currB == nullptr) { currB = headB; } while (currB != nullptr) { if (currA == currB) { return currA; } else { currB = currB-&gt;next; } } currA = currA-&gt;next; } return NULL; } }; 对于A中的每一个节点，循环B中的节点，判断二者是否相等。注意，需要遍历完B时，及时转到B的头节点。 双指针交替 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if (headA == nullptr || headB == nullptr) { return NULL; } ListNode* currA = headA; ListNode* currB = headB; while (currA != currB) { currA = (currA == nullptr) ? headB : currA-&gt;next; currB = (currB == nullptr) ? headA : currB-&gt;next; } return currA; } }; 即便A、B不相等，但是在第一轮遍历后交换位置，因为两个指针所走的路程相同，交换位置后，如果找到相交节点就返回相交节点，如果没有相交节点两者会走过A+B个节点后同时到达空指针。 ","link":"https://liutianci99.github.io/post/xiang-jiao-lian-biao/"},{"title":"删除链表倒数第N个节点","content":"题目 Leetcode 26: 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 题解 转化为删除第N个节点 class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { int length = 0; ListNode* curr; ListNode* dummy = new ListNode(); dummy-&gt;next = head; curr = head; while(curr != nullptr) { curr = curr-&gt;next; length ++; } int right_pos = length - n; curr = dummy; while(right_pos --) { curr = curr-&gt;next; } curr-&gt;next = curr-&gt;next-&gt;next; return dummy-&gt;next; } }; 通过循环得到链表的长度，将倒数的问题转化为正数的问题。通过增加虚拟头节点统一节点操作，正常写删除节点的代码即可。 ","link":"https://liutianci99.github.io/post/shan-chu-lian-biao-dao-shu-di-n-ge-jie-dian/"}]}