{"posts":[{"title":"三数之和","content":"题目 Leetcode ： 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 **注意：**答案中不可以包含重复的三元组。 题解 哈希表（去重麻烦） 双指针 class Solution { public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; result; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums.size() - 2; i ++) { if (nums[i] &gt; 0) return result; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } int left = i + 1; int right = nums.size() - 1; while (left &lt; right) { if (nums[i] + nums[left] + nums[right] &gt; 0) { right --; } else if (nums[i] + nums[left] + nums[right] &lt; 0) { left ++; } else { result.push_back(vector&lt;int&gt;{nums[i], nums[left], nums[right]}); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left ++; while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right --; left ++; right --; } } } return result; } }; 重点在于先排序再去重。遍历数组，通过遍历的数i确定left，right。确定i，left，right的同时对三者进行去重。 ","link":"https://liutianci99.github.io/post/san-shu-zhi-he/"},{"title":"四数之和","content":"题目 Leetcode 18： 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 题解 双指针 class Solution { public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; result; for (int i = 0; i &lt; nums.size(); i ++) { if (nums[i] &gt; 0 &amp;&amp; nums[i] &gt; target) break; if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i]) continue; for (int j = i + 1; j &lt; nums.size(); j ++) { if (nums[j] + nums[i] &gt; 0 &amp;&amp; nums[j] + nums[i] &gt; target) break; if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; int left = j + 1; int right = nums.size() - 1; while (left &lt; right) { if ((long)nums[i] + nums[j] + nums[left] + nums[right] &gt; target) { right --; } else if ((long)nums[i] + nums[j] + nums[left] + nums[right] &lt; target) { left ++; } else { result.push_back(vector&lt;int&gt;{nums[i], nums[j], nums[left], nums[right]}); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left ++; while (left &lt; right &amp;&amp; nums[right] == nums[right -1]) right --; left ++; right --; } } } } return result; } }; 和三数之和差不多，关键在于剪枝、去重。以及四数相加可能造成溢出，加上long变成长整型。 ","link":"https://liutianci99.github.io/post/si-shu-zhi-he/"},{"title":"螺旋数组","content":"题目 Leetcode 59： Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order 题解 循环模拟（注意边界值） #include &lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n)); int loop = n / 2; int i, j; int start_i = 0, start_j = 0; int offset = 1; int number = 1; while(loop --) { i = start_i; j = start_j; // 循环是左闭右开的区间 for(;j &lt; n -offset; j++) { matrix[i][j] = number; number ++; } for(;i &lt; n - offset; i ++) { matrix[i][j] = number; number ++; } for(;j &gt; start_j; j--) { matrix[i][j] = number; number ++; } for(;i &gt; start_i; i--) { matrix[i][j] = number; number ++; } offset ++; start_j ++; start_i ++; } if(n % 2 == 1) { matrix[n/2][n/2] = n * n; } for(i = 0; i &lt; n; i++) { for(j = 0; j &lt; n; j++) { cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; &quot;\\n&quot;; } } 先生成矩阵然后往矩阵里填入数。根据不同的n确定需要螺旋几圈。把每一圈分为左闭右开的四次循环，注意每圈的边界值都不一样。 ","link":"https://liutianci99.github.io/post/luo-xuan-shu-zu/"},{"title":"相交链表","content":"题目 Leetcode 面试题02.07： 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 题解 暴力循环 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if (headA == nullptr || headB == nullptr) { return NULL; } ListNode* currA; ListNode* currB; currA = headA; currB = headB; while (currA != nullptr) { if (currB == nullptr) { currB = headB; } while (currB != nullptr) { if (currA == currB) { return currA; } else { currB = currB-&gt;next; } } currA = currA-&gt;next; } return NULL; } }; 对于A中的每一个节点，循环B中的节点，判断二者是否相等。注意，需要遍历完B时，及时转到B的头节点。 双指针交替 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if (headA == nullptr || headB == nullptr) { return NULL; } ListNode* currA = headA; ListNode* currB = headB; while (currA != currB) { currA = (currA == nullptr) ? headB : currA-&gt;next; currB = (currB == nullptr) ? headA : currB-&gt;next; } return currA; } }; 即便A、B不相等，但是在第一轮遍历后交换位置，因为两个指针所走的路程相同，交换位置后，如果找到相交节点就返回相交节点，如果没有相交节点两者会走过A+B个节点后同时到达空指针。 ","link":"https://liutianci99.github.io/post/xiang-jiao-lian-biao/"},{"title":"删除链表倒数第N个节点","content":"题目 Leetcode 26: 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 题解 转化为删除第N个节点 class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { int length = 0; ListNode* curr; ListNode* dummy = new ListNode(); dummy-&gt;next = head; curr = head; while(curr != nullptr) { curr = curr-&gt;next; length ++; } int right_pos = length - n; curr = dummy; while(right_pos --) { curr = curr-&gt;next; } curr-&gt;next = curr-&gt;next-&gt;next; return dummy-&gt;next; } }; 通过循环得到链表的长度，将倒数的问题转化为正数的问题。通过增加虚拟头节点统一节点操作，正常写删除节点的代码即可。 ","link":"https://liutianci99.github.io/post/shan-chu-lian-biao-dao-shu-di-n-ge-jie-dian/"}]}